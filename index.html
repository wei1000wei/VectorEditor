<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>矢量图编辑器</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;}
        html,body{height:100%;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;}
        .container{display:grid;grid-template-columns:280px 1fr;grid-template-rows:80px 1fr;height:100vh;background:#1e1e1e;color:#e0e0e0;}
        .top-left{grid-column:1;grid-row:1;display:flex;align-items:center;justify-content:center;background:#252526;border-right:1px solid #3c3c3c;border-bottom:1px solid #3c3c3c;}
        .logo{font-size:24px;font-weight:bold;color:#007acc;}
        .top-right{grid-column:2;grid-row:1;display:flex;align-items:center;padding:0 20px;background:#2d2d2d;border-bottom:1px solid #3c3c3c;gap:15px;flex-wrap:wrap;}
        .toolbar-group{display:flex;gap:8px;align-items:center;padding:0 10px;border-left:1px solid #3c3c3c;}
        .toolbar-group:first-child{border-left:none;}
        .toolbar-btn{width:36px;height:36px;border:none;background:#3c3c3c;color:#e0e0e0;border-radius:4px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all 0.15s;font-size:16px;}
        .toolbar-btn:hover{background:#4c4c4c;}
        .toolbar-btn.active{background:#007acc;color:white;}
        .toolbar-btn:disabled{opacity:0.4;cursor:not-allowed;}
        .input-field{width:120px;height:32px;background:#3c3c3c;border:1px solid #3c3c3c;border-radius:4px;color:#e0e0e0;padding:0 10px;outline:none;}
        .input-field:focus{border-color:#007acc;}
        .left-panel{grid-column:1;grid-row:2;background:#252526;border-right:1px solid #3c3c3c;padding:15px;display:flex;flex-direction:column;gap:15px;}
        .tools-title{font-size:14px;color:#888;margin-bottom:5px;}
        .tools-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;}
        .tool-btn{aspect-ratio:1;border:none;background:#3c3c3c;color:#e0e0e0;border-radius:6px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all 0.15s;font-size:18px;}
        .tool-btn:hover{background:#4c4c4c;}
        .tool-btn.active{background:#007acc;color:white;box-shadow:0 2px 8px rgba(0,122,204,0.3);}
        .canvas-area{grid-column:2;grid-row:2;background:#1e1e1e;overflow:auto;position:relative;}
        .canvas-container{min-width:100%;min-height:100%;display:flex;align-items:center;justify-content:center;padding:40px;}
        #svgCanvas{background:#ffffff;box-shadow:0 4px 20px rgba(0,0,0,0.3);cursor:crosshair;}
        .color-picker-modal{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#2d2d2d;border-radius:10px;padding:20px;box-shadow:0 10px 40px rgba(0,0,0,0.5);z-index:1000;min-width:360px;display:none;}
        .color-picker-modal.show{display:block;}
        .modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;}
        .modal-title{font-size:16px;font-weight:600;}
        .modal-close{width:28px;height:28px;border:none;background:#3c3c3c;color:#e0e0e0;border-radius:4px;cursor:pointer;}
        .color-tabs{display:flex;gap:8px;margin-bottom:15px;}
        .color-tab{flex:1;padding:8px;border:none;background:#3c3c3c;color:#e0e0e0;border-radius:4px;cursor:pointer;}
        .color-tab.active{background:#007acc;color:white;}
        .tab-content{display:none;}
        .tab-content.active{display:block;}
        .rgba-controls{display:grid;grid-template-columns:1fr 80px;gap:10px;margin-bottom:15px;}
        .color-slider{width:100%;height:8px;border-radius:4px;outline:none;}
        .color-preview{width:100%;height:60px;border-radius:6px;margin-bottom:15px;border:2px solid #3c3c3c;}
        .gradient-controls{display:flex;flex-direction:column;gap:12px;}
        .gradient-type-select{display:flex;gap:8px;}
        .gradient-type-btn{flex:1;padding:10px;border:none;background:#3c3c3c;color:#e0e0e0;border-radius:4px;cursor:pointer;}
        .gradient-type-btn.active{background:#007acc;color:white;}
        .color-stop{display:flex;gap:10px;align-items:center;}
        .color-stop input[type="color"]{width:40px;height:32px;border:none;border-radius:4px;cursor:pointer;}
        .modal-actions{display:flex;gap:10px;justify-content:flex-end;margin-top:15px;}
        .modal-btn{padding:10px 20px;border:none;border-radius:4px;cursor:pointer;font-weight:500;}
        .modal-btn.cancel{background:#3c3c3c;color:#e0e0e0;}
        .modal-btn.confirm{background:#007acc;color:white;}
        .download-modal{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#2d2d2d;border-radius:10px;padding:25px;box-shadow:0 10px 40px rgba(0,0,0,0.5);z-index:1000;min-width:300px;display:none;}
        .download-modal.show{display:block;}
        .download-options{display:flex;flex-direction:column;gap:10px;margin:15px 0;}
        .download-option{padding:12px;border:2px solid #3c3c3c;border-radius:6px;cursor:pointer;text-align:center;transition:all 0.15s;}
        .download-option:hover{border-color:#007acc;}
        .overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:999;display:none;}
        .overlay.show{display:block;}
        .separator{height:1px;background:#3c3c3c;margin:10px 0;}
    </style>
</head>
<body>
    <div class="container">
        <div class="top-left">
            <div class="logo">VectEdit</div>
        </div>
        <div class="top-right" id="topBar">
            <div class="toolbar-group">
                <input type="text" class="input-field" id="projectName" value="未命名项目" placeholder="项目名称">
            </div>
            <div class="toolbar-group">
                <button class="toolbar-btn" id="undoBtn" title="撤回 (Ctrl+Z)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 7v6h6"/>
                        <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 13"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="redoBtn" title="重做 (Ctrl+Y)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 7v6h-6"/>
                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 13"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="pasteBtn" title="粘贴 (Ctrl+V)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                        <rect x="8" y="2" width="8" height="4" rx="1" ry="1"/>
                    </svg>
                </button>
            </div>
            <div class="toolbar-group">
                <button class="toolbar-btn" id="zoomOutBtn" title="缩小 (Ctrl+-)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="M21 21l-4.35-4.35"/>
                        <path d="M8 11h6"/>
                    </svg>
                </button>
                <span id="zoomLevel" style="min-width:50px;text-align:center;">100%</span>
                <button class="toolbar-btn" id="zoomInBtn" title="放大 (Ctrl++)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="M21 21l-4.35-4.35"/>
                        <path d="M11 8v6"/>
                        <path d="M8 11h6"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="resetZoomBtn" title="重置缩放">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                        <path d="M3 3v5h5"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="gridBtn" title="显示/隐藏网格">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                        <path d="M3 9h18"/>
                        <path d="M3 15h18"/>
                        <path d="M9 3v18"/>
                        <path d="M15 3v18"/>
                    </svg>
                </button>
            </div>
            <div class="toolbar-group" id="elementTools" style="display:none;">
                <button class="toolbar-btn" id="groupBtn" title="组合 (Ctrl+G)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7" rx="1"/>
                        <rect x="14" y="3" width="7" height="7" rx="1"/>
                        <rect x="14" y="14" width="7" height="7" rx="1"/>
                        <rect x="3" y="14" width="7" height="7" rx="1"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="ungroupBtn" title="拆散">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7" rx="1"/>
                        <rect x="14" y="3" width="7" height="7" rx="1"/>
                        <rect x="14" y="14" width="7" height="7" rx="1"/>
                        <rect x="3" y="14" width="7" height="7" rx="1"/>
                        <path d="M8 8h.01"/>
                        <path d="M16 8h.01"/>
                        <path d="M8 16h.01"/>
                        <path d="M16 16h.01"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="forwardBtn" title="前移一层">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="18,15 12,9 6,15"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="backwardBtn" title="后移一层">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6,9 12,15 18,9"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="frontBtn" title="置顶">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="18,17 12,11 6,17"/>
                        <polyline points="18,7 12,1 6,7"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="backBtn" title="置底">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6,7 12,13 18,7"/>
                        <polyline points="6,17 12,23 18,17"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="copyBtn" title="复制 (Ctrl+C)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
            </div>
            <div class="toolbar-group" id="shapeTools" style="display:none;">
                <button class="toolbar-btn" id="fillColorBtn" title="填充颜色">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 11H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2z"/>
                        <polyline points="7,11 7,21 12,16 17,21 17,11"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="strokeColorBtn" title="边框颜色">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                        <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                    </svg>
                </button>
                <input type="number" class="input-field" id="strokeWidth" value="2" min="0" max="100" style="width:70px;">
            </div>
            <div class="toolbar-group" id="pathTools" style="display:none;">
                <button class="toolbar-btn active" id="curveBtn" title="曲线">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12a9 9 0 0 1-9-9 9.75 9.75 0 0 0-6.74 2.74L3 13"/>
                        <path d="M3 12a9 9 0 0 1 9 9 9.75 9.75 0 0 0 6.74-2.74L21 11"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="polylineBtn" title="折线">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="4,20 8,8 12,16 16,4 20,12"/>
                    </svg>
                </button>
            </div>
        </div>
        <div class="left-panel">
            <div>
                <div class="tools-title">工具</div>
                <div class="tools-grid">
                    <button class="tool-btn active" data-tool="select" title="选择 (V)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                        </svg>
                    </button>
                    <button class="tool-btn" data-tool="path" title="变形 (A)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 20V10M18 20V4M6 20v-4"/>
                            <circle cx="12" cy="8" r="2"/>
                            <circle cx="18" cy="2" r="2"/>
                            <circle cx="6" cy="14" r="2"/>
                        </svg>
                    </button>
                    <button class="tool-btn" data-tool="brush" title="画笔 (B)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                            <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                        </svg>
                    </button>
                    <button class="tool-btn" data-tool="eraser" title="橡皮 (E)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M20 20H10L3 13a2.12 2.12 0 010-3l7-7a2.12 2.12 0 013 0l7 7a2.12 2.12 0 010 3z"/>
                            <path d="M6.5 10.5L13.5 17.5"/>
                        </svg>
                    </button>
                    <button class="tool-btn" data-tool="fill" title="填充 (F)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M19 11H5a2 2 0 01-2-2V5a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2z"/>
                            <polyline points="7,11 7,21 12,16 17,21 17,11"/>
                        </svg>
                    </button>
                    <button class="tool-btn" data-tool="text" title="文本 (T)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="4,7 4,4 20,4 20,7"/>
                            <line x1="9" y1="20" x2="15" y2="20"/>
                            <line x1="12" y1="4" x2="12" y2="20"/>
                        </svg>
                    </button>
                    <button class="tool-btn" data-tool="line" title="线段 (L)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="5" y1="19" x2="19" y2="5"/>
                        </svg>
                    </button>
                    <button class="tool-btn" data-tool="rect" title="矩形 (R)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                        </svg>
                    </button>
                    <button class="tool-btn" data-tool="ellipse" title="椭圆 (O)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <ellipse cx="12" cy="12" rx="10" ry="6"/>
                        </svg>
                    </button>
                    <button class="tool-btn" data-tool="download" title="下载 (Ctrl+S)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                            <polyline points="7,10 12,15 17,10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                    </button>
                    <button class="tool-btn" data-tool="upload" title="上传">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                            <polyline points="17,8 12,3 7,8"/>
                            <line x1="12" y1="3" x2="12" y2="15"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="separator"></div>
            <div>
                <div class="tools-title">颜色</div>
                <div style="display:flex;gap:10px;margin-top:10px;">
                    <div style="flex:1;">
                        <div style="font-size:12px;color:#888;margin-bottom:5px;">填充</div>
                        <div id="fillColorPreview" style="width:100%;height:36px;background:#3498db;border-radius:6px;cursor:pointer;border:2px solid #3c3c3c;"></div>
                    </div>
                    <div style="flex:1;">
                        <div style="font-size:12px;color:#888;margin-bottom:5px;">边框</div>
                        <div id="strokeColorPreview" style="width:100%;height:36px;background:#2c3e50;border-radius:6px;cursor:pointer;border:2px solid #3c3c3c;"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="canvas-area">
            <div class="canvas-container">
                <svg id="svgCanvas" width="1200" height="800" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                            <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#e0e0e0" stroke-width="0.5"/>
                        </pattern>
                        <pattern id="grid-large" width="100" height="100" patternUnits="userSpaceOnUse">
                            <rect width="100" height="100" fill="url(#grid)"/>
                            <path d="M 100 0 L 0 0 0 100" fill="none" stroke="#c0c0c0" stroke-width="1"/>
                        </pattern>
                    </defs>
                    <g id="canvasContent">
                        <rect id="gridRect" width="100%" height="100%" fill="url(#grid-large)" style="display:none;"/>
                    </g>
                </svg>
            </div>
        </div>
    </div>
    <div class="overlay" id="overlay"></div>
    <div class="color-picker-modal" id="colorPickerModal">
        <div class="modal-header">
            <div class="modal-title" id="colorPickerTitle">选择颜色</div>
            <button class="modal-close" id="closeColorPicker">×</button>
        </div>
        <div class="color-tabs">
            <button class="color-tab active" data-tab="rgba">纯色</button>
            <button class="color-tab" data-tab="linear">线性渐变</button>
            <button class="color-tab" data-tab="radial">径向渐变</button>
        </div>
        <div class="tab-content active" id="rgbaTab">
            <div class="color-preview" id="rgbaPreview"></div>
            <div class="rgba-controls">
                <input type="range" id="redSlider" min="0" max="255" value="52" class="color-slider" style="background:linear-gradient(to right,#000,#f00);">
                <span id="redValue">52</span>
            </div>
            <div class="rgba-controls">
                <input type="range" id="greenSlider" min="0" max="255" value="152" class="color-slider" style="background:linear-gradient(to right,#000,#0f0);">
                <span id="greenValue">152</span>
            </div>
            <div class="rgba-controls">
                <input type="range" id="blueSlider" min="0" max="255" value="219" class="color-slider" style="background:linear-gradient(to right,#000,#00f);">
                <span id="blueValue">219</span>
            </div>
            <div class="rgba-controls">
                <input type="range" id="alphaSlider" min="0" max="100" value="100" class="color-slider" style="background:linear-gradient(to right,transparent,#fff);">
                <span id="alphaValue">100%</span>
            </div>
        </div>
        <div class="tab-content" id="linearTab">
            <div class="gradient-controls">
                <div class="color-preview" id="linearPreview"></div>
                <div class="gradient-type-select">
                    <button class="gradient-type-btn active" data-dir="to right">→</button>
                    <button class="gradient-type-btn" data-dir="to bottom">↓</button>
                    <button class="gradient-type-btn" data-dir="to bottom right">↘</button>
                    <button class="gradient-type-btn" data-dir="to top right">↗</button>
                </div>
                <div class="color-stop">
                    <input type="color" id="linearColor1" value="#3498db">
                    <span>到</span>
                    <input type="color" id="linearColor2" value="#9b59b6">
                </div>
            </div>
        </div>
        <div class="tab-content" id="radialTab">
            <div class="gradient-controls">
                <div class="color-preview" id="radialPreview"></div>
                <div class="color-stop">
                    <input type="color" id="radialColor1" value="#3498db">
                    <span>到</span>
                    <input type="color" id="radialColor2" value="#2c3e50">
                </div>
            </div>
        </div>
        <div class="modal-actions">
            <button class="modal-btn cancel" id="cancelColor">取消</button>
            <button class="modal-btn confirm" id="confirmColor">确认</button>
        </div>
    </div>
    <div class="download-modal" id="downloadModal">
        <div class="modal-header">
            <div class="modal-title">下载文件</div>
            <button class="modal-close" id="closeDownloadModal">×</button>
        </div>
        <div class="download-options">
            <div class="download-option" data-format="svg">SVG 格式</div>
            <div class="download-option" data-format="html">HTML 格式</div>
            <div class="download-option" data-format="xml">XML 格式</div>
        </div>
    </div>
    <input type="file" id="fileInput" accept=".svg,.html,.xml" style="display:none;">
    <script>
        const svg=document.getElementById('svgCanvas');
        const canvasContent=document.getElementById('canvasContent');
        const gridRect=document.getElementById('gridRect');
        const toolBtns=document.querySelectorAll('.tool-btn');
        const undoBtn=document.getElementById('undoBtn');
        const redoBtn=document.getElementById('redoBtn');
        const pasteBtn=document.getElementById('pasteBtn');
        const groupBtn=document.getElementById('groupBtn');
        const ungroupBtn=document.getElementById('ungroupBtn');
        const forwardBtn=document.getElementById('forwardBtn');
        const backwardBtn=document.getElementById('backwardBtn');
        const frontBtn=document.getElementById('frontBtn');
        const backBtn=document.getElementById('backBtn');
        const copyBtn=document.getElementById('copyBtn');
        const fillColorBtn=document.getElementById('fillColorBtn');
        const strokeColorBtn=document.getElementById('strokeColorBtn');
        const strokeWidthInput=document.getElementById('strokeWidth');
        const curveBtn=document.getElementById('curveBtn');
        const polylineBtn=document.getElementById('polylineBtn');
        const fillColorPreview=document.getElementById('fillColorPreview');
        const strokeColorPreview=document.getElementById('strokeColorPreview');
        const colorPickerModal=document.getElementById('colorPickerModal');
        const overlay=document.getElementById('overlay');
        const downloadModal=document.getElementById('downloadModal');
        const fileInput=document.getElementById('fileInput');
        const zoomInBtn=document.getElementById('zoomInBtn');
        const zoomOutBtn=document.getElementById('zoomOutBtn');
        const resetZoomBtn=document.getElementById('resetZoomBtn');
        const zoomLevelSpan=document.getElementById('zoomLevel');
        const gridBtn=document.getElementById('gridBtn');

        let currentTool='select';
        let selectedElements=[];
        let isDrawing=false;
        let isDragging=false;
        let startX=0,startY=0;
        let currentPath=null;
        let currentElement=null;
        let clipboard=null;
        let history=[];
        let historyIndex=-1;
        let fillColor='#3498db';
        let strokeColor='#2c3e50';
        let strokeWidth=2;
        let pathMode='curve';
        let colorPickerTarget='fill';
        let currentColorTab='rgba';
        let linearGradientDir='to right';
        let tempColor={r:52,g:152,b:219,a:100};
        let dragMode=null;
        let dragHandle=null;
        let originalTransform='';
        let zoom=1;
        let showGrid=false;
        let isRotating=false;
        let rotationStartAngle=0;
        let isPathEditing=false;
        let pathPoints=[];
        let selectedPoint=null;

        function saveState(){
            historyIndex++;
            history=history.slice(0,historyIndex);
            history.push(canvasContent.innerHTML);
            if(history.length>50)history.shift(),historyIndex--;
            updateHistoryButtons();
        }

        function updateHistoryButtons(){
            undoBtn.disabled=historyIndex<=0;
            redoBtn.disabled=historyIndex>=history.length-1;
        }

        function undo(){
            if(historyIndex>0){
                historyIndex--;
                canvasContent.innerHTML=history[historyIndex];
                clearSelection();
                updateHistoryButtons();
            }
        }

        function redo(){
            if(historyIndex<history.length-1){
                historyIndex++;
                canvasContent.innerHTML=history[historyIndex];
                clearSelection();
                updateHistoryButtons();
            }
        }

        toolBtns.forEach(btn=>{
            btn.addEventListener('click',()=>{
                toolBtns.forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
                currentTool=btn.dataset.tool;
                updateTopBar();
                clearSelection();
                if(currentTool==='download')showDownloadModal();
                if(currentTool==='upload')fileInput.click();
            });
        });

        function updateTopBar(){
            const elementTools=document.getElementById('elementTools');
            const shapeTools=document.getElementById('shapeTools');
            const pathTools=document.getElementById('pathTools');
            elementTools.style.display=selectedElements.length>0?'flex':'none';
            if(selectedElements.length>0){
                const el=selectedElements[0];
                const tag=el.tagName.toLowerCase();
                const isClosedShape=['rect','ellipse','circle','polygon','path'].includes(tag);
                const isOpenShape=['line','polyline'].includes(tag);
                const isText=tag==='text';
                if(isClosedShape){
                    shapeTools.style.display='flex';
                    fillColorBtn.style.display='flex';
                }else if(isOpenShape||isText||currentTool==='brush'){
                    shapeTools.style.display='flex';
                    fillColorBtn.style.display='none';
                }else{
                    shapeTools.style.display='none';
                }
            }else if(['rect','ellipse'].includes(currentTool)){
                shapeTools.style.display='flex';
                fillColorBtn.style.display='flex';
            }else if(['line','text','brush'].includes(currentTool)){
                shapeTools.style.display='flex';
                fillColorBtn.style.display='none';
            }else{
                shapeTools.style.display='none';
            }
            pathTools.style.display=currentTool==='path'?'flex':'none';
        }

        function clearSelection(){
            selectedElements.forEach(el=>{
                const outline=el.getAttribute('data-outline');
                if(outline){
                    const outlineEl=document.getElementById(outline);
                    if(outlineEl)outlineEl.parentNode.removeChild(outlineEl);
                    el.removeAttribute('data-outline');
                }
            });
            selectedElements=[];
            clearPathPoints();
            updateTopBar();
        }

        function selectElement(el){
            if(el.tagName==='SVG'||el.id==='canvasContent'||el.id==='gridRect')return;
            if(!selectedElements.includes(el)){
                selectedElements.push(el);
                drawOutline(el);
            }
            updateTopBar();
        }

        function getElementTransform(el){
            const transform=el.getAttribute('transform')||'';
            const rotateMatch=transform.match(/rotate\(([^)]+)\)/);
            let angle=0;
            let cx=0,cy=0;
            if(rotateMatch){
                const parts=rotateMatch[1].split(/\s*,\s*/);
                angle=parseFloat(parts[0]);
                if(parts.length>=3){
                    cx=parseFloat(parts[1]);
                    cy=parseFloat(parts[2]);
                }
            }
            return{angle:angle,cx:cx,cy:cy};
        }
        function getRotatedCorners(el){
            const bbox=el.getBBox();
            const transform=getElementTransform(el);
            const angleRad=transform.angle*Math.PI/180;
            const cos=Math.cos(angleRad);
            const sin=Math.sin(angleRad);
            let cx=transform.cx;
            let cy=transform.cy;
            if(cx===0&&cy===0){
                cx=bbox.x+bbox.width/2;
                cy=bbox.y+bbox.height/2;
            }
            const corners=[
                {x:bbox.x,y:bbox.y},
                {x:bbox.x+bbox.width,y:bbox.y},
                {x:bbox.x+bbox.width,y:bbox.y+bbox.height},
                {x:bbox.x,y:bbox.y+bbox.height}
            ];
            const rotatedCorners=corners.map(corner=>{
                const dx=corner.x-cx;
                const dy=corner.y-cy;
                return{
                    x:cx+dx*cos-dy*sin,
                    y:cy+dx*sin+dy*cos
                };
            });
            return rotatedCorners;
        }
        function getTransformedBBox(el){
            const rotatedCorners=getRotatedCorners(el);
            const xs=rotatedCorners.map(c=>c.x);
            const ys=rotatedCorners.map(c=>c.y);
            const minX=Math.min(...xs);
            const maxX=Math.max(...xs);
            const minY=Math.min(...ys);
            const maxY=Math.max(...ys);
            return{x:minX,y:minY,width:maxX-minX,height:maxY-minY};
        }
        function drawOutline(el){
            const tbbox=getTransformedBBox(el);
            const scale=1/zoom;
            const padding=5*scale;
            const handleRadius=5*scale;
            const g=document.createElementNS('http://www.w3.org/2000/svg','g');
            const rect=document.createElementNS('http://www.w3.org/2000/svg','rect');
            rect.setAttribute('x',tbbox.x-padding);
            rect.setAttribute('y',tbbox.y-padding);
            rect.setAttribute('width',tbbox.width+padding*2);
            rect.setAttribute('height',tbbox.height+padding*2);
            rect.setAttribute('fill','none');
            rect.setAttribute('stroke','#007acc');
            rect.setAttribute('stroke-width',1*scale);
            rect.setAttribute('stroke-dasharray',5*scale+','+5*scale);
            g.appendChild(rect);
            const handles=[
                {x:tbbox.x-padding,y:tbbox.y-padding,c:'nw'},
                {x:tbbox.x+tbbox.width/2,y:tbbox.y-padding,c:'n'},
                {x:tbbox.x+tbbox.width+padding,y:tbbox.y-padding,c:'ne'},
                {x:tbbox.x-padding,y:tbbox.y+tbbox.height/2,c:'w'},
                {x:tbbox.x+tbbox.width+padding,y:tbbox.y+tbbox.height/2,c:'e'},
                {x:tbbox.x-padding,y:tbbox.y+tbbox.height+padding,c:'sw'},
                {x:tbbox.x+tbbox.width/2,y:tbbox.y+tbbox.height+padding,c:'s'},
                {x:tbbox.x+tbbox.width+padding,y:tbbox.y+tbbox.height+padding,c:'se'}
            ];
            handles.forEach(h=>{
                const circle=document.createElementNS('http://www.w3.org/2000/svg','circle');
                circle.setAttribute('cx',h.x);
                circle.setAttribute('cy',h.y);
                circle.setAttribute('r',handleRadius);
                circle.setAttribute('fill','white');
                circle.setAttribute('stroke','#007acc');
                circle.setAttribute('stroke-width',2*scale);
                circle.setAttribute('data-handle',h.c);
                circle.style.cursor='pointer';
                g.appendChild(circle);
            });
            const rotateCircle=document.createElementNS('http://www.w3.org/2000/svg','circle');
            rotateCircle.setAttribute('cx',tbbox.x+tbbox.width/2);
            rotateCircle.setAttribute('cy',tbbox.y-padding-25*scale);
            rotateCircle.setAttribute('r',6*scale);
            rotateCircle.setAttribute('fill','#007acc');
            rotateCircle.setAttribute('data-handle','rotate');
            rotateCircle.style.cursor='pointer';
            g.appendChild(rotateCircle);
            const id='outline-'+Math.random().toString(36).substr(2,9);
            g.setAttribute('id',id);
            el.setAttribute('data-outline',id);
            svg.appendChild(g);
        }

        function getMousePos(e){
            const rect=svg.getBoundingClientRect();
            return{x:e.clientX-rect.left,y:e.clientY-rect.top};
        }

        function getElementCenter(el){
            const bbox=el.getBBox();
            return{x:bbox.x+bbox.width/2,y:bbox.y+bbox.height/2};
        }

        function getAngle(cx,cy,px,py){
            return Math.atan2(py-cy,px-cx)*180/Math.PI;
        }

        function rotateElement(el,angle,cx,cy){
            const currentTransform=el.getAttribute('transform')||'';
            const rotateMatch=currentTransform.match(/rotate\(([^)]+)\)/);
            let currentAngle=0;
            if(rotateMatch){
                currentAngle=parseFloat(rotateMatch[1]);
            }
            const newAngle=currentAngle+angle;
            const newTransform=`rotate(${newAngle},${cx},${cy})`;
            el.setAttribute('transform',newTransform);
        }

        svg.addEventListener('mousedown',e=>{
            const pos=getMousePos(e);
            startX=pos.x;startY=pos.y;
            if(currentTool==='select'){
                const el=e.target;
                if(el.closest('[id^="outline-"]')){
                    const handle=el.getAttribute('data-handle');
                    if(handle){
                        if(handle==='rotate'&&selectedElements.length===1){
                            isRotating=true;
                            const center=getElementCenter(selectedElements[0]);
                            rotationStartAngle=getAngle(center.x,center.y,pos.x,pos.y);
                        }else if(selectedElements.length===1){
                            isDragging=true;
                            dragHandle=handle;
                        }
                        return;
                    }
                }
                const target=el.closest('g,rect,ellipse,line,path,text,polygon,polyline,circle');
                if(target&&target.id!=='canvasContent'&&target.id!=='gridRect'){
                    if(!e.ctrlKey)clearSelection();
                    selectElement(target);
                    isDragging=true;
                    dragMode='move';
                }else if(el.tagName==='SVG'||el.id==='canvasContent'||el.id==='gridRect'){
                    clearSelection();
                }
            }else if(currentTool==='path'){
                const el=e.target;
                if(el.classList&&el.classList.contains('path-point')){
                    isPathEditing=true;
                    selectedPoint=el;
                }else{
                    const target=el.closest('g,rect,ellipse,line,path,text,polygon,polyline,circle');
                    if(target&&target.id!=='canvasContent'&&target.id!=='gridRect'){
                        if(!e.ctrlKey)clearSelection();
                        selectElement(target);
                        drawPathPoints(target);
                    }else if(el.tagName==='SVG'||el.id==='canvasContent'||el.id==='gridRect'){
                        clearPathPoints();
                        clearSelection();
                    }
                }
            }else if(currentTool==='rect'){
                isDrawing=true;
                currentElement=document.createElementNS('http://www.w3.org/2000/svg','rect');
                currentElement.setAttribute('x',startX);
                currentElement.setAttribute('y',startY);
                currentElement.setAttribute('width',0);
                currentElement.setAttribute('height',0);
                currentElement.setAttribute('fill',fillColor);
                currentElement.setAttribute('stroke',strokeColor);
                currentElement.setAttribute('stroke-width',strokeWidth);
                canvasContent.appendChild(currentElement);
            }else if(currentTool==='ellipse'){
                isDrawing=true;
                currentElement=document.createElementNS('http://www.w3.org/2000/svg','ellipse');
                currentElement.setAttribute('cx',startX);
                currentElement.setAttribute('cy',startY);
                currentElement.setAttribute('rx',0);
                currentElement.setAttribute('ry',0);
                currentElement.setAttribute('fill',fillColor);
                currentElement.setAttribute('stroke',strokeColor);
                currentElement.setAttribute('stroke-width',strokeWidth);
                canvasContent.appendChild(currentElement);
            }else if(currentTool==='line'){
                isDrawing=true;
                currentElement=document.createElementNS('http://www.w3.org/2000/svg','line');
                currentElement.setAttribute('x1',startX);
                currentElement.setAttribute('y1',startY);
                currentElement.setAttribute('x2',startX);
                currentElement.setAttribute('y2',startY);
                currentElement.setAttribute('stroke',strokeColor);
                currentElement.setAttribute('stroke-width',strokeWidth);
                canvasContent.appendChild(currentElement);
            }else if(currentTool==='brush'){
                isDrawing=true;
                currentPath=document.createElementNS('http://www.w3.org/2000/svg','path');
                currentPath.setAttribute('d',`M${startX},${startY}`);
                currentPath.setAttribute('fill','none');
                currentPath.setAttribute('stroke',strokeColor);
                currentPath.setAttribute('stroke-width',strokeWidth);
                currentPath.setAttribute('stroke-linecap','round');
                currentPath.setAttribute('stroke-linejoin','round');
                canvasContent.appendChild(currentPath);
            }else if(currentTool==='text'){
                const text=prompt('输入文本:');
                if(text){
                    const textEl=document.createElementNS('http://www.w3.org/2000/svg','text');
                    textEl.setAttribute('x',pos.x);
                    textEl.setAttribute('y',pos.y);
                    textEl.setAttribute('fill',fillColor);
                    textEl.setAttribute('font-size','24');
                    textEl.textContent=text;
                    canvasContent.appendChild(textEl);
                    saveState();
                }
            }else if(currentTool==='fill'){
                const el=e.target;
                const target=el.closest('g,rect,ellipse,line,path,text,polygon,polyline,circle');
                if(target){
                    target.setAttribute('fill',fillColor);
                    saveState();
                }
            }else if(currentTool==='eraser'){
                const el=e.target;
                const target=el.closest('g,rect,ellipse,line,path,text,polygon,polyline,circle');
                if(target){
                    if(target.parentNode)target.parentNode.removeChild(target);
                    saveState();
                }
            }
        });

        svg.addEventListener('mousemove',e=>{
            const pos=getMousePos(e);
            const dx=pos.x-startX;
            const dy=pos.y-startY;
            if(isDrawing){
                if(currentTool==='rect'){
                    const x=Math.min(startX,pos.x);
                    const y=Math.min(startY,pos.y);
                    const w=Math.abs(pos.x-startX);
                    const h=Math.abs(pos.y-startY);
                    currentElement.setAttribute('x',x);
                    currentElement.setAttribute('y',y);
                    currentElement.setAttribute('width',w);
                    currentElement.setAttribute('height',h);
                }else if(currentTool==='ellipse'){
                    const cx=(startX+pos.x)/2;
                    const cy=(startY+pos.y)/2;
                    const rx=Math.abs(pos.x-startX)/2;
                    const ry=Math.abs(pos.y-startY)/2;
                    currentElement.setAttribute('cx',cx);
                    currentElement.setAttribute('cy',cy);
                    currentElement.setAttribute('rx',rx);
                    currentElement.setAttribute('ry',ry);
                }else if(currentTool==='line'){
                    currentElement.setAttribute('x2',pos.x);
                    currentElement.setAttribute('y2',pos.y);
                }else if(currentTool==='brush'){
                    const d=currentPath.getAttribute('d');
                    currentPath.setAttribute('d',d+` L${pos.x},${pos.y}`);
                }
            }
            if(isRotating&&selectedElements.length===1){
                const el=selectedElements[0];
                const center=getElementCenter(el);
                const currentAngle=getAngle(center.x,center.y,pos.x,pos.y);
                const angleDiff=currentAngle-rotationStartAngle;
                rotateElement(el,angleDiff,center.x,center.y);
                rotationStartAngle=currentAngle;
                refreshOutlines();
            }
            if(isDragging&&currentTool==='select'){
                if(dragMode==='move'&&selectedElements.length>0){
                    selectedElements.forEach(el=>{
                        moveElement(el,dx,dy);
                    });
                    startX=pos.x;
                    startY=pos.y;
                    refreshOutlines();
                }else if(dragHandle&&selectedElements.length===1){
                    const el=selectedElements[0];
                    resizeElement(el,dragHandle,dx,dy);
                    startX=pos.x;
                    startY=pos.y;
                    refreshOutlines();
                }
            }
            if(isPathEditing&&selectedPoint){
                const pointType=selectedPoint.getAttribute('data-type');
                const pointIndex=parseInt(selectedPoint.getAttribute('data-index'));
                const el=selectedElements[0];
                const tag=el.tagName.toLowerCase();
                if(tag==='ellipse'||tag==='circle'){
                    if(!tempPolygon){
                        const cx=parseFloat(el.getAttribute('cx')||0);
                        const cy=parseFloat(el.getAttribute('cy')||0);
                        let rx,ry;
                        if(tag==='circle'){
                            rx=ry=parseFloat(el.getAttribute('r')||0);
                        }else{
                            rx=parseFloat(el.getAttribute('rx')||0);
                            ry=parseFloat(el.getAttribute('ry')||0);
                        }
                        const k=0.551915;
                        const points=[
                            {x:cx,y:cy-ry},
                            {x:cx+rx*k,y:cy-ry},
                            {x:cx+rx,y:cy-ry*k},
                            {x:cx+rx,y:cy},
                            {x:cx+rx,y:cy+ry*k},
                            {x:cx+rx*k,y:cy+ry},
                            {x:cx,y:cy+ry},
                            {x:cx-rx*k,y:cy+ry},
                            {x:cx-rx,y:cy+ry*k},
                            {x:cx-rx,y:cy},
                            {x:cx-rx,y:cy-ry*k},
                            {x:cx-rx*k,y:cy-ry}
                        ];
                        const d=`M${points[0].x},${points[0].y} C${points[1].x},${points[1].y} ${points[2].x},${points[2].y} ${points[3].x},${points[3].y} C${points[4].x},${points[4].y} ${points[5].x},${points[5].y} ${points[6].x},${points[6].y} C${points[7].x},${points[7].y} ${points[8].x},${points[8].y} ${points[9].x},${points[9].y} C${points[10].x},${points[10].y} ${points[11].x},${points[11].y} ${points[0].x},${points[0].y}Z`;
                        const path=document.createElementNS('http://www.w3.org/2000/svg','path');
                        path.setAttribute('d',d);
                        path.setAttribute('fill',el.getAttribute('fill')||'none');
                        path.setAttribute('stroke',el.getAttribute('stroke')||'none');
                        path.setAttribute('stroke-width',el.getAttribute('stroke-width')||'0');
                        canvasContent.insertBefore(path,el.nextSibling);
                        tempPolygon=path;
                        el.style.display='none';
                    }
                    if(tempPolygon){
                        const d=tempPolygon.getAttribute('d');
                        const parts=d.match(/[a-zA-Z]|-?[\d.]+/g)||[];
                        const dx=pos.x-startX;
                        const dy=pos.y-startY;
                        if(pointType==='main'){
                            const idx=pointIndex;
                            if(idx===0){
                                parts[2]+=dy;
                                parts[35]+=dy;
                                parts[37]+=dy;
                            }else if(idx===1){
                                parts[8]+=dx;
                                parts[10]+=dx;
                            }else if(idx===2){
                                parts[17]+=dy;
                                parts[20]+=dy;
                            }else if(idx===3){
                                parts[26]+=dx;
                                parts[29]+=dx;
                            }
                        }
                        tempPolygon.setAttribute('d',parts.join(''));
                        startX=pos.x;
                        startY=pos.y;
                        drawPathPoints(tempPolygon);
                        refreshOutlines();
                    }
                }else if(tag==='path'){
                    const parts=el.getAttribute('d').match(/[a-zA-Z]|-?[\d.]+/g)||[];
                    let coordIndex=0;
                    for(let i=0;i<parts.length;i++){
                        if('ML'.includes(parts[i].toUpperCase())){
                            if(coordIndex===pointIndex){
                                parts[i+1]=pos.x;
                                parts[i+2]=pos.y;
                                break;
                            }
                            coordIndex++;
                        }
                    }
                    el.setAttribute('d',parts.join(''));
                }else if(tag==='polygon'||tag==='polyline'){
                    const points=el.getAttribute('points').split(/[,\s]+/).filter(p=>p);
                    points[pointIndex*2]=pos.x;
                    points[pointIndex*2+1]=pos.y;
                    el.setAttribute('points',points.join(','));
                }else if(tag==='rect'){
                    const x=parseFloat(el.getAttribute('x')||0);
                    const y=parseFloat(el.getAttribute('y')||0);
                    const w=parseFloat(el.getAttribute('width')||0);
                    const h=parseFloat(el.getAttribute('height')||0);
                    const corners=[
                        {x:x,y:y},
                        {x:x+w,y:y},
                        {x:x+w,y:y+h},
                        {x:x,y:y+h}
                    ];
                    corners[pointIndex].x=pos.x;
                    corners[pointIndex].y=pos.y;
                    const newX=Math.min(corners[0].x,corners[1].x,corners[2].x,corners[3].x);
                    const newY=Math.min(corners[0].y,corners[1].y,corners[2].y,corners[3].y);
                    const newW=Math.max(corners[0].x,corners[1].x,corners[2].x,corners[3].x)-newX;
                    const newH=Math.max(corners[0].y,corners[1].y,corners[2].y,corners[3].y)-newY;
                    if(newW>0&&newH>0){
                        el.setAttribute('x',newX);
                        el.setAttribute('y',newY);
                        el.setAttribute('width',newW);
                        el.setAttribute('height',newH);
                    }
                }else if(tag==='ellipse'){
                    const cx=parseFloat(el.getAttribute('cx')||0);
                    const cy=parseFloat(el.getAttribute('cy')||0);
                    const rx=parseFloat(el.getAttribute('rx')||0);
                    const ry=parseFloat(el.getAttribute('ry')||0);
                    if(pointIndex===0){
                        el.setAttribute('ry',Math.abs(cy-pos.y));
                    }else if(pointIndex===1){
                        el.setAttribute('rx',Math.abs(pos.x-cx));
                    }else if(pointIndex===2){
                        el.setAttribute('ry',Math.abs(pos.y-cy));
                    }else if(pointIndex===3){
                        el.setAttribute('rx',Math.abs(cx-pos.x));
                    }
                }else if(tag==='line'){
                    if(pointIndex===0){
                        el.setAttribute('x1',pos.x);
                        el.setAttribute('y1',pos.y);
                    }else{
                        el.setAttribute('x2',pos.x);
                        el.setAttribute('y2',pos.y);
                    }
                }
                if(tag!=='ellipse'&&tag!=='circle'){
                    startX=pos.x;
                    startY=pos.y;
                    drawPathPoints(el);
                    refreshOutlines();
                }
            }
        });

        function moveElement(el,dx,dy){
            const tag=el.tagName.toLowerCase();
            if(tag==='rect'){
                el.setAttribute('x',parseFloat(el.getAttribute('x')||0)+dx);
                el.setAttribute('y',parseFloat(el.getAttribute('y')||0)+dy);
            }else if(tag==='ellipse'||tag==='circle'){
                el.setAttribute('cx',parseFloat(el.getAttribute('cx')||0)+dx);
                el.setAttribute('cy',parseFloat(el.getAttribute('cy')||0)+dy);
            }else if(tag==='line'){
                el.setAttribute('x1',parseFloat(el.getAttribute('x1')||0)+dx);
                el.setAttribute('y1',parseFloat(el.getAttribute('y1')||0)+dy);
                el.setAttribute('x2',parseFloat(el.getAttribute('x2')||0)+dx);
                el.setAttribute('y2',parseFloat(el.getAttribute('y2')||0)+dy);
            }else if(tag==='text'){
                el.setAttribute('x',parseFloat(el.getAttribute('x')||0)+dx);
                el.setAttribute('y',parseFloat(el.getAttribute('y')||0)+dy);
            }else if(tag==='path'){
                const d=el.getAttribute('d');
                const newD=transformPath(d,dx,dy);
                el.setAttribute('d',newD);
            }else if(tag==='polygon'||tag==='polyline'){
                const points=el.getAttribute('points');
                const newPoints=transformPoints(points,dx,dy);
                el.setAttribute('points',newPoints);
            }else if(tag==='g'){
                const children=el.children;
                for(let i=0;i<children.length;i++){
                    moveElement(children[i],dx,dy);
                }
            }
        }

        function transformPath(d,dx,dy){
            const parts=d.match(/[a-zA-Z]|-?[\d.]+/g)||[];
            let result='';
            let i=0;
            while(i<parts.length){
                const cmd=parts[i];
                result+=cmd;
                i++;
                if('ML'.includes(cmd.toUpperCase())){
                    result+=(parseFloat(parts[i])+dx)+','+(parseFloat(parts[i+1])+dy);
                    i+=2;
                }else if('HV'.includes(cmd.toUpperCase())){
                    if(cmd.toUpperCase()==='H'){
                        result+=(parseFloat(parts[i])+dx);
                        i++;
                    }else{
                        result+=(parseFloat(parts[i])+dy);
                        i++;
                    }
                }else if('CQS'.includes(cmd.toUpperCase())){
                    const numPoints=cmd.toUpperCase()==='C'?6:cmd.toUpperCase()==='Q'?4:2;
                    for(let j=0;j<numPoints;j+=2){
                        result+=(parseFloat(parts[i+j])+dx)+','+(parseFloat(parts[i+j+1])+dy);
                    }
                    i+=numPoints;
                }
            }
            return result;
        }

        function transformPoints(points,dx,dy){
            const coords=points.split(/[,\s]+/).filter(p=>p);
            let result='';
            for(let i=0;i<coords.length;i+=2){
                const x=parseFloat(coords[i])+dx;
                const y=parseFloat(coords[i+1])+dy;
                result+=x+','+y+' ';
            }
            return result.trim();
        }

        let isResizingRotated=false;
        let tempPolygon=null;
        let tempPolygonHandle=null;
        let originalRotatedCorners=null;
        let rotatedHandleIndex=-1;
        function getHandleCornerIndex(handle){
            const map={
                'nw':0,'ne':1,'se':2,'sw':3
            };
            return map[handle]!==undefined?map[handle]:-1;
        }
        function resizeElement(el,handle,dx,dy){
            const transform=getElementTransform(el);
            if(transform.angle!==0&&['rect','ellipse'].includes(el.tagName.toLowerCase())){
                const cornerIdx=getHandleCornerIndex(handle);
                if(cornerIdx>=0){
                    if(!isResizingRotated){
                        isResizingRotated=true;
                        originalRotatedCorners=getRotatedCorners(el);
                        rotatedHandleIndex=cornerIdx;
                    }
                    const corners=[...originalRotatedCorners];
                    corners[cornerIdx].x+=dx;
                    corners[cornerIdx].y+=dy;
                    const pointsStr=corners.map(c=>`${c.x},${c.y}`).join(' ');
                    if(!tempPolygon){
                        const polygon=document.createElementNS('http://www.w3.org/2000/svg','polygon');
                        polygon.setAttribute('fill',el.getAttribute('fill')||'none');
                        polygon.setAttribute('stroke',el.getAttribute('stroke')||'none');
                        polygon.setAttribute('stroke-width',el.getAttribute('stroke-width')||'0');
                        canvasContent.insertBefore(polygon,el.nextSibling);
                        tempPolygon=polygon;
                    }
                    tempPolygon.setAttribute('points',pointsStr);
                    el.style.display='none';
                }
                return;
            }
            const tag=el.tagName.toLowerCase();
            if(tag==='rect'){
                let x=parseFloat(el.getAttribute('x')||0);
                let y=parseFloat(el.getAttribute('y')||0);
                let w=parseFloat(el.getAttribute('width')||0);
                let h=parseFloat(el.getAttribute('height')||0);
                if(handle.includes('e'))w+=dx;
                if(handle.includes('w')){x+=dx;w-=dx;}
                if(handle.includes('s'))h+=dy;
                if(handle.includes('n')){y+=dy;h-=dy;}
                if(w>0){el.setAttribute('width',w);el.setAttribute('x',x);}
                if(h>0){el.setAttribute('height',h);el.setAttribute('y',y);}
            }else if(tag==='ellipse'){
                let cx=parseFloat(el.getAttribute('cx')||0);
                let cy=parseFloat(el.getAttribute('cy')||0);
                let rx=parseFloat(el.getAttribute('rx')||0);
                let ry=parseFloat(el.getAttribute('ry')||0);
                if(handle==='e'){
                    rx+=dx;
                }else if(handle==='w'){
                    cx+=dx/2;
                    rx-=dx/2;
                }else if(handle==='s'){
                    ry+=dy;
                }else if(handle==='n'){
                    cy+=dy/2;
                    ry-=dy/2;
                }else if(handle==='se'){
                    rx+=dx;
                    ry+=dy;
                }else if(handle==='sw'){
                    cx+=dx/2;
                    rx-=dx/2;
                    ry+=dy;
                }else if(handle==='ne'){
                    rx+=dx;
                    cy+=dy/2;
                    ry-=dy/2;
                }else if(handle==='nw'){
                    cx+=dx/2;
                    cy+=dy/2;
                    rx-=dx/2;
                    ry-=dy/2;
                }
                if(rx>0){
                    el.setAttribute('rx',rx);
                    el.setAttribute('cx',cx);
                }
                if(ry>0){
                    el.setAttribute('ry',ry);
                    el.setAttribute('cy',cy);
                }
            }else if(tag==='circle'){
                let r=parseFloat(el.getAttribute('r')||0);
                r+=(Math.abs(dx)+Math.abs(dy))/2;
                if(r>0)el.setAttribute('r',r);
            }else if(tag==='text'){
                let fontSize=parseFloat(el.getAttribute('font-size')||24);
                fontSize+=(dy/10);
                if(fontSize>5)el.setAttribute('font-size',fontSize);
            }
        }

        function refreshOutlines(){
            selectedElements.forEach(el=>{
                const outlineId=el.getAttribute('data-outline');
                if(outlineId){
                    const oldOutline=document.getElementById(outlineId);
                    if(oldOutline)oldOutline.parentNode.removeChild(oldOutline);
                    drawOutline(el);
                }
            });
        }

        function drawPathPoints(el){
            clearPathPoints();
            const tag=el.tagName.toLowerCase();
            const scale=1/zoom;
            const g=document.createElementNS('http://www.w3.org/2000/svg','g');
            g.setAttribute('id','path-points');
            if(tag==='ellipse'||tag==='circle'){
                const cx=parseFloat(el.getAttribute('cx')||0);
                const cy=parseFloat(el.getAttribute('cy')||0);
                let rx,ry;
                if(tag==='circle'){
                    rx=ry=parseFloat(el.getAttribute('r')||0);
                }else{
                    rx=parseFloat(el.getAttribute('rx')||0);
                    ry=parseFloat(el.getAttribute('ry')||0);
                }
                const mainPoints=[
                    {x:cx,y:cy-ry,type:'main'},
                    {x:cx+rx,y:cy,type:'main'},
                    {x:cx,y:cy+ry,type:'main'},
                    {x:cx-rx,y:cy,type:'main'}
                ];
                mainPoints.forEach((p,index)=>{
                    const circle=document.createElementNS('http://www.w3.org/2000/svg','circle');
                    circle.setAttribute('cx',p.x);
                    circle.setAttribute('cy',p.y);
                    circle.setAttribute('r',6*scale);
                    circle.setAttribute('fill','#007acc');
                    circle.setAttribute('stroke','white');
                    circle.setAttribute('stroke-width',2*scale);
                    circle.setAttribute('class','path-point');
                    circle.setAttribute('data-type','main');
                    circle.setAttribute('data-index',index);
                    circle.style.cursor='move';
                    g.appendChild(circle);
                });
                for(let i=0;i<4;i++){
                    const p1=mainPoints[i];
                    const p2=mainPoints[(i+1)%4];
                    const dx=p2.x-p1.x;
                    const dy=p2.y-p1.y;
                    const midX=p1.x+dx*0.5;
                    const midY=p1.y+dy*0.5;
                    const handleDist=0.551915;
                    let h1x,h1y,h2x,h2y;
                    if(i===0){
                        h1x=midX+rx*handleDist;h1y=midY-ry;
                        h2x=midX+rx;h2y=midY-ry*handleDist;
                    }else if(i===1){
                        h1x=midX+rx;h1y=midY+ry*handleDist;
                        h2x=midX+rx*handleDist;h2y=midY+ry;
                    }else if(i===2){
                        h1x=midX-rx*handleDist;h1y=midY+ry;
                        h2x=midX-rx;h2y=midY+ry*handleDist;
                    }else{
                        h1x=midX-rx;h1y=midY-ry*handleDist;
                        h2x=midX-rx*handleDist;h2y=midY-ry;
                    }
                    const handle1=document.createElementNS('http://www.w3.org/2000/svg','polygon');
                    handle1.setAttribute('points',`${h1x},${h1y-4*scale} ${h1x+4*scale},${h1y} ${h1x},${h1y+4*scale} ${h1x-4*scale},${h1y}`);
                    handle1.setAttribute('fill','white');
                    handle1.setAttribute('stroke','#007acc');
                    handle1.setAttribute('stroke-width',2*scale);
                    handle1.setAttribute('class','path-point');
                    handle1.setAttribute('data-type','handle');
                    g.appendChild(handle1);
                    const handle2=document.createElementNS('http://www.w3.org/2000/svg','polygon');
                    handle2.setAttribute('points',`${h2x},${h2y-4*scale} ${h2x+4*scale},${h2y} ${h2x},${h2y+4*scale} ${h2x-4*scale},${h2y}`);
                    handle2.setAttribute('fill','white');
                    handle2.setAttribute('stroke','#007acc');
                    handle2.setAttribute('stroke-width',2*scale);
                    handle2.setAttribute('class','path-point');
                    handle2.setAttribute('data-type','handle');
                    g.appendChild(handle2);
                    const line=document.createElementNS('http://www.w3.org/2000/svg','line');
                    line.setAttribute('x1',h1x);
                    line.setAttribute('y1',h1y);
                    line.setAttribute('x2',h2x);
                    line.setAttribute('y2',h2y);
                    line.setAttribute('stroke','#007acc');
                    line.setAttribute('stroke-width',1*scale);
                    line.setAttribute('stroke-dasharray',3*scale+','+3*scale);
                    g.appendChild(line);
                }
            }else{
                const points=[];
                if(tag==='path'){
                    const d=el.getAttribute('d');
                    const parts=d.match(/[a-zA-Z]|-?[\d.]+/g)||[];
                    for(let i=0;i<parts.length;i++){
                        if('ML'.includes(parts[i].toUpperCase())){
                            points.push({x:parseFloat(parts[i+1]),y:parseFloat(parts[i+2])});
                        }
                    }
                }else if(tag==='polygon'||tag==='polyline'){
                    const coords=el.getAttribute('points').split(/[,\s]+/).filter(p=>p);
                    for(let i=0;i<coords.length;i+=2){
                        points.push({x:parseFloat(coords[i]),y:parseFloat(coords[i+1])});
                    }
                }else if(tag==='rect'){
                    const x=parseFloat(el.getAttribute('x')||0);
                    const y=parseFloat(el.getAttribute('y')||0);
                    const w=parseFloat(el.getAttribute('width')||0);
                    const h=parseFloat(el.getAttribute('height')||0);
                    points.push({x:x,y:y});
                    points.push({x:x+w,y:y});
                    points.push({x:x+w,y:y+h});
                    points.push({x:x,y:y+h});
                }else if(tag==='line'){
                    const x1=parseFloat(el.getAttribute('x1')||0);
                    const y1=parseFloat(el.getAttribute('y1')||0);
                    const x2=parseFloat(el.getAttribute('x2')||0);
                    const y2=parseFloat(el.getAttribute('y2')||0);
                    points.push({x:x1,y:y1});
                    points.push({x:x2,y:y2});
                }
                points.forEach((p,index)=>{
                    const circle=document.createElementNS('http://www.w3.org/2000/svg','circle');
                    circle.setAttribute('cx',p.x);
                    circle.setAttribute('cy',p.y);
                    circle.setAttribute('r',5*scale);
                    circle.setAttribute('fill','#007acc');
                    circle.setAttribute('stroke','white');
                    circle.setAttribute('stroke-width',2*scale);
                    circle.setAttribute('class','path-point');
                    circle.setAttribute('data-type','main');
                    circle.setAttribute('data-index',index);
                    circle.style.cursor='move';
                    g.appendChild(circle);
                });
            }
            svg.appendChild(g);
        }

        function clearPathPoints(){
            const pointsGroup=document.getElementById('path-points');
            if(pointsGroup)pointsGroup.parentNode.removeChild(pointsGroup);
        }

        svg.addEventListener('mouseup',()=>{
            if(isDrawing){
                isDrawing=false;
                saveState();
            }
            if(isDragging||isRotating||isPathEditing||isResizingRotated){
                if((isResizingRotated||isPathEditing)&&tempPolygon){
                    selectedElements.forEach(el=>{
                        if(el.tagName.toLowerCase()==='rect'||el.tagName.toLowerCase()==='ellipse'||el.tagName.toLowerCase()==='circle'){
                            if(el.parentNode)el.parentNode.removeChild(el);
                        }
                    });
                    clearSelection();
                    selectElement(tempPolygon);
                    tempPolygon=null;
                    originalRotatedCorners=null;
                    rotatedHandleIndex=-1;
                }
                isDragging=false;
                isRotating=false;
                isPathEditing=false;
                isResizingRotated=false;
                dragMode=null;
                dragHandle=null;
                selectedPoint=null;
                saveState();
            }
        });

        undoBtn.addEventListener('click',undo);
        redoBtn.addEventListener('click',redo);

        document.addEventListener('keydown',e=>{
            if(e.ctrlKey&&e.key==='z')undo();
            if(e.ctrlKey&&e.key==='y')redo();
            if(e.ctrlKey&&e.key==='c'&&selectedElements.length>0){
                clipboard=selectedElements.map(el=>el.cloneNode(true));
            }
            if(e.ctrlKey&&e.key==='v'&&clipboard){
                clipboard.forEach(el=>{
                    const clone=el.cloneNode(true);
                    canvasContent.appendChild(clone);
                });
                saveState();
            }
            if(e.key==='Delete'&&selectedElements.length>0){
                selectedElements.forEach(el=>{
                    if(el.parentNode)el.parentNode.removeChild(el);
                });
                clearSelection();
                saveState();
            }
            const tools={v:'select',a:'path',b:'brush',e:'eraser',f:'fill',t:'text',l:'line',r:'rect',o:'ellipse'};
            if(tools[e.key.toLowerCase()]){
                toolBtns.forEach(btn=>{
                    btn.classList.remove('active');
                    if(btn.dataset.tool===tools[e.key.toLowerCase()])btn.classList.add('active');
                });
                currentTool=tools[e.key.toLowerCase()];
                updateTopBar();
            }
        });

        copyBtn.addEventListener('click',()=>{
            if(selectedElements.length>0){
                clipboard=selectedElements.map(el=>el.cloneNode(true));
            }
        });

        pasteBtn.addEventListener('click',()=>{
            if(clipboard){
                clipboard.forEach(el=>{
                    const clone=el.cloneNode(true);
                    canvasContent.appendChild(clone);
                });
                saveState();
            }
        });

        fillColorPreview.addEventListener('click',()=>openColorPicker('fill'));
        strokeColorPreview.addEventListener('click',()=>openColorPicker('stroke'));
        fillColorBtn.addEventListener('click',()=>openColorPicker('fill'));
        strokeColorBtn.addEventListener('click',()=>openColorPicker('stroke'));

        function openColorPicker(target){
            colorPickerTarget=target;
            colorPickerModal.classList.add('show');
            overlay.classList.add('show');
            updateColorPreviews();
        }

        function closeColorPicker(){
            colorPickerModal.classList.remove('show');
            overlay.classList.remove('show');
        }

        document.getElementById('closeColorPicker').addEventListener('click',closeColorPicker);
        document.getElementById('cancelColor').addEventListener('click',closeColorPicker);
        document.getElementById('confirmColor').addEventListener('click',()=>{
            if(colorPickerTarget==='fill'){
                if(currentColorTab==='rgba'){
                    fillColor=`rgba(${tempColor.r},${tempColor.g},${tempColor.b},${tempColor.a/100})`;
                }else if(currentColorTab==='linear'){
                    fillColor=`url(#linearGrad)`;
                    const defs=svg.querySelector('defs')||document.createElementNS('http://www.w3.org/2000/svg','defs');
                    if(!defs.parentNode)svg.insertBefore(defs,svg.firstChild);
                    let grad=defs.querySelector('#linearGrad');
                    if(!grad){
                        grad=document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
                        grad.setAttribute('id','linearGrad');
                        defs.appendChild(grad);
                    }
                    const dirMap={'to right':'0 0,1 0','to bottom':'0 0,0 1','to bottom right':'0 0,1 1','to top right':'0 1,1 0'};
                    const coords=dirMap[linearGradientDir];
                    const [x1,y1,x2,y2]=coords.match(/[\d.]+/g);
                    grad.setAttribute('x1',x1);
                    grad.setAttribute('y1',y1);
                    grad.setAttribute('x2',x2);
                    grad.setAttribute('y2',y2);
                    grad.innerHTML='';
                    const stop1=document.createElementNS('http://www.w3.org/2000/svg','stop');
                    stop1.setAttribute('offset','0%');
                    stop1.setAttribute('stop-color',document.getElementById('linearColor1').value);
                    grad.appendChild(stop1);
                    const stop2=document.createElementNS('http://www.w3.org/2000/svg','stop');
                    stop2.setAttribute('offset','100%');
                    stop2.setAttribute('stop-color',document.getElementById('linearColor2').value);
                    grad.appendChild(stop2);
                }else if(currentColorTab==='radial'){
                    fillColor=`url(#radialGrad)`;
                    const defs=svg.querySelector('defs')||document.createElementNS('http://www.w3.org/2000/svg','defs');
                    if(!defs.parentNode)svg.insertBefore(defs,svg.firstChild);
                    let grad=defs.querySelector('#radialGrad');
                    if(!grad){
                        grad=document.createElementNS('http://www.w3.org/2000/svg','radialGradient');
                        grad.setAttribute('id','radialGrad');
                        defs.appendChild(grad);
                    }
                    grad.innerHTML='';
                    const stop1=document.createElementNS('http://www.w3.org/2000/svg','stop');
                    stop1.setAttribute('offset','0%');
                    stop1.setAttribute('stop-color',document.getElementById('radialColor1').value);
                    grad.appendChild(stop1);
                    const stop2=document.createElementNS('http://www.w3.org/2000/svg','stop');
                    stop2.setAttribute('offset','100%');
                    stop2.setAttribute('stop-color',document.getElementById('radialColor2').value);
                    grad.appendChild(stop2);
                }
                fillColorPreview.style.background=fillColor;
                if(selectedElements.length>0){
                    selectedElements.forEach(el=>{
                        el.setAttribute('fill',fillColor);
                    });
                    saveState();
                }
            }else{
                if(currentColorTab==='rgba'){
                    strokeColor=`rgba(${tempColor.r},${tempColor.g},${tempColor.b},${tempColor.a/100})`;
                }else{
                    strokeColor=document.getElementById('linearColor1').value;
                }
                strokeColorPreview.style.background=strokeColor;
                if(selectedElements.length>0){
                    selectedElements.forEach(el=>{
                        el.setAttribute('stroke',strokeColor);
                    });
                    saveState();
                }
            }
            closeColorPicker();
        });

        document.querySelectorAll('.color-tab').forEach(tab=>{
            tab.addEventListener('click',()=>{
                document.querySelectorAll('.color-tab').forEach(t=>t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c=>c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab+'Tab').classList.add('active');
                currentColorTab=tab.dataset.tab;
                updateColorPreviews();
            });
        });

        ['red','green','blue','alpha'].forEach(color=>{
            const slider=document.getElementById(color+'Slider');
            const value=document.getElementById(color+'Value');
            slider.addEventListener('input',()=>{
                if(color==='alpha'){
                    value.textContent=slider.value+'%';
                    tempColor.a=parseInt(slider.value);
                }else{
                    value.textContent=slider.value;
                    tempColor[color[0]]=parseInt(slider.value);
                }
                updateColorPreviews();
            });
        });

        document.querySelectorAll('.gradient-type-btn').forEach(btn=>{
            btn.addEventListener('click',()=>{
                document.querySelectorAll('.gradient-type-btn').forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
                linearGradientDir=btn.dataset.dir;
                updateColorPreviews();
            });
        });

        ['linearColor1','linearColor2','radialColor1','radialColor2'].forEach(id=>{
            document.getElementById(id).addEventListener('input',updateColorPreviews);
        });

        function updateColorPreviews(){
            document.getElementById('rgbaPreview').style.background=`rgba(${tempColor.r},${tempColor.g},${tempColor.b},${tempColor.a/100})`;
            document.getElementById('linearPreview').style.background=`linear-gradient(${linearGradientDir},${document.getElementById('linearColor1').value},${document.getElementById('linearColor2').value})`;
            document.getElementById('radialPreview').style.background=`radial-gradient(circle,${document.getElementById('radialColor1').value},${document.getElementById('radialColor2').value})`;
        }

        strokeWidthInput.addEventListener('input',()=>{
            strokeWidth=parseInt(strokeWidthInput.value)||2;
            if(selectedElements.length>0){
                selectedElements.forEach(el=>{
                    el.setAttribute('stroke-width',strokeWidth);
                });
                saveState();
            }
        });

        curveBtn.addEventListener('click',()=>{
            curveBtn.classList.add('active');
            polylineBtn.classList.remove('active');
            pathMode='curve';
        });

        polylineBtn.addEventListener('click',()=>{
            polylineBtn.classList.add('active');
            curveBtn.classList.remove('active');
            pathMode='polyline';
        });

        forwardBtn.addEventListener('click',()=>{
            selectedElements.forEach(el=>{
                const next=el.nextSibling;
                if(next&&next.nextSibling){
                    canvasContent.insertBefore(el,next.nextSibling);
                }
            });
            saveState();
        });

        backwardBtn.addEventListener('click',()=>{
            selectedElements.forEach(el=>{
                const prev=el.previousSibling;
                if(prev&&prev.previousSibling){
                    canvasContent.insertBefore(el,prev);
                }
            });
            saveState();
        });

        frontBtn.addEventListener('click',()=>{
            selectedElements.forEach(el=>canvasContent.appendChild(el));
            saveState();
        });

        backBtn.addEventListener('click',()=>{
            const first=canvasContent.firstChild;
            selectedElements.forEach(el=>canvasContent.insertBefore(el,first));
            saveState();
        });

        function showDownloadModal(){
            downloadModal.classList.add('show');
            overlay.classList.add('show');
        }

        function closeDownloadModal(){
            downloadModal.classList.remove('show');
            overlay.classList.remove('show');
        }

        document.getElementById('closeDownloadModal').addEventListener('click',closeDownloadModal);
        overlay.addEventListener('click',()=>{
            closeColorPicker();
            closeDownloadModal();
        });

        document.querySelectorAll('.download-option').forEach(opt=>{
            opt.addEventListener('click',()=>{
                downloadFile(opt.dataset.format);
                closeDownloadModal();
            });
        });

        function downloadFile(format){
            const name=document.getElementById('projectName').value||'untitled';
            const tempSvg=svg.cloneNode(true);
            const tempCanvasContent=tempSvg.querySelector('#canvasContent');
            if(tempCanvasContent)tempCanvasContent.removeAttribute('transform');
            let content,type,ext;
            if(format==='svg'){
                content=tempSvg.outerHTML;
                type='image/svg+xml';
                ext='svg';
            }else if(format==='html'){
                content=`<!DOCTYPE html><html><body>${tempSvg.outerHTML}</body></html>`;
                type='text/html';
                ext='html';
            }else{
                content=tempSvg.outerHTML;
                type='application/xml';
                ext='xml';
            }
            const blob=new Blob([content],{type});
            const a=document.createElement('a');
            a.href=URL.createObjectURL(blob);
            a.download=name+'.'+ext;
            a.click();
        }

        fileInput.addEventListener('change',e=>{
            const file=e.target.files[0];
            if(file){
                const reader=new FileReader();
                reader.onload=function(ev){
                    try{
                        const parser=new DOMParser();
                        const doc=parser.parseFromString(ev.target.result,'text/xml');
                        const svgEl=doc.querySelector('svg');
                        if(svgEl){
                            canvasContent.innerHTML=gridRect.outerHTML+svgEl.innerHTML;
                            saveState();
                        }
                    }catch(err){
                        alert('文件解析失败');
                    }
                };
                reader.readAsText(file);
            }
            fileInput.value='';
        });

        zoomInBtn.addEventListener('click',()=>{
            zoom=Math.min(zoom*1.2,5);
            updateZoom();
        });

        zoomOutBtn.addEventListener('click',()=>{
            zoom=Math.max(zoom/1.2,0.1);
            updateZoom();
        });

        resetZoomBtn.addEventListener('click',()=>{
            zoom=1;
            updateZoom();
        });

        gridBtn.addEventListener('click',()=>{
            showGrid=!showGrid;
            gridRect.style.display=showGrid?'block':'none';
            gridBtn.classList.toggle('active',showGrid);
        });

        function updateZoom(){
            canvasContent.setAttribute('transform',`scale(${zoom})`);
            zoomLevelSpan.textContent=Math.round(zoom*100)+'%';
            refreshOutlines();
        }

        document.addEventListener('keydown',e=>{
            if(e.ctrlKey&&(e.key==='='||e.key==='+')){
                e.preventDefault();
                zoom=Math.min(zoom*1.2,5);
                updateZoom();
            }
            if(e.ctrlKey&&e.key==='-'){
                e.preventDefault();
                zoom=Math.max(zoom/1.2,0.1);
                updateZoom();
            }
            if(e.ctrlKey&&e.key==='0'){
                e.preventDefault();
                zoom=1;
                updateZoom();
            }
        });

        saveState();
        updateColorPreviews();
    </script>
</body>
</html>
